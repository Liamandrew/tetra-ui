{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "slot",
  "title": "Slot",
  "description": "",
  "registryDependencies": [],
  "files": [
    {
      "path": "../../packages/tetra-ui/src/components/slot.tsx",
      "content": "import { Children, cloneElement, isValidElement } from \"react\";\nimport type { Pressable as RNPressable, View as RNView } from \"react-native\";\nimport { mergeRefs } from \"@/lib/utils\";\n\n// Constants\nconst HANDLER_REGEX = /^on[A-Z]/;\n\n// Types\ntype AnyProps = Record<string, unknown>;\n\n// Components\nconst View = ({\n  ref,\n  children,\n  ...viewProps\n}: React.ComponentPropsWithRef<typeof RNView>) => {\n  const child = Children.only(children) as React.ReactElement<\n    React.ComponentPropsWithRef<typeof RNView>\n  >;\n\n  if (!isValidElement(child)) {\n    console.warn(\"View expects a single React element as children\");\n    return null;\n  }\n\n  const childRef = \"ref\" in child ? child.ref : undefined;\n  const mergedRef = childRef\n    ? mergeRefs(ref, childRef as React.Ref<RNView>)\n    : ref;\n\n  return cloneElement(child, {\n    ...mergeProps(viewProps, child.props as AnyProps),\n    ref: mergedRef,\n  });\n};\n\nconst Pressable = ({\n  ref,\n  children,\n  ...pressableProps\n}: React.ComponentPropsWithRef<typeof RNPressable>) => {\n  const child = Children.only(children) as React.ReactElement<\n    React.ComponentProps<typeof RNPressable>\n  >;\n\n  if (!isValidElement(child)) {\n    console.warn(\"Pressable expects a single React element as children\");\n    return null;\n  }\n\n  const childRef = \"ref\" in child ? child.ref : undefined;\n  const mergedRef = childRef\n    ? mergeRefs(ref, childRef as React.Ref<RNView>)\n    : ref;\n\n  return cloneElement(child, {\n    ...mergeProps(pressableProps, child.props as AnyProps),\n    ref: mergedRef,\n  });\n};\n\n// Utils\nfunction mergeHandler(\n  slotPropValue: unknown,\n  childPropValue: unknown\n): ((...args: unknown[]) => unknown) | unknown {\n  if (\n    slotPropValue &&\n    childPropValue &&\n    typeof childPropValue === \"function\" &&\n    typeof slotPropValue === \"function\"\n  ) {\n    return (...args: unknown[]) => {\n      const result = childPropValue(...args);\n      slotPropValue(...args);\n      return result;\n    };\n  }\n  return slotPropValue || childPropValue;\n}\n\nfunction mergeStyle(slotPropValue: unknown, childPropValue: unknown) {\n  return [slotPropValue, childPropValue];\n}\n\nfunction mergeClassName(slotPropValue: unknown, childPropValue: unknown) {\n  return [slotPropValue, childPropValue].filter(Boolean).join(\" \");\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    if (!Object.hasOwn(childProps, propName)) {\n      continue;\n    }\n\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    if (HANDLER_REGEX.test(propName)) {\n      overrideProps[propName] = mergeHandler(slotPropValue, childPropValue);\n    } else if (propName === \"style\") {\n      overrideProps[propName] = mergeStyle(slotPropValue, childPropValue);\n    } else if (propName === \"className\") {\n      overrideProps[propName] = mergeClassName(slotPropValue, childPropValue);\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\nexport const Slot = {\n  View,\n  Pressable,\n};\n",
      "type": "registry:ui"
    }
  ],
  "type": "registry:ui"
}
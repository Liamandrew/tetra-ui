{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "popover",
  "type": "registry:ui",
  "title": "Popover",
  "description": "",
  "dependencies": [
    "react-native-reanimated",
    "react-native-safe-area-context",
    "react-native-screens"
  ],
  "registryDependencies": [
    "@tetra-ui/portal",
    "@tetra-ui/slot"
  ],
  "files": [
    {
      "path": "../../packages/tetra-ui/src/components/popover.tsx",
      "content": "import {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  type DimensionValue,\n  type GestureResponderEvent,\n  type LayoutChangeEvent,\n  type LayoutRectangle,\n  Pressable,\n  StyleSheet,\n  type View,\n  type ViewStyle,\n} from \"react-native\";\nimport Animated, {\n  Extrapolation,\n  interpolate,\n  type SharedValue,\n  useAnimatedStyle,\n  useSharedValue,\n  withTiming,\n} from \"react-native-reanimated\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { FullWindowOverlay } from \"react-native-screens\";\nimport { Uniwind } from \"uniwind\";\nimport { useRelativePosition } from \"@/hooks/use-relative-position\";\nimport { cn, mergeRefs } from \"@/lib/utils\";\nimport { Portal } from \"./portal\";\nimport * as Slot from \"./slot\";\n\n// Constants\nconst ANIMATION_DURATION = 200;\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\n// Types\ntype LayoutPosition = {\n  pageX: number;\n  pageY: number;\n  width: number;\n  height: number;\n};\n\ntype PopoverContextProps = {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  visibilityProgress: SharedValue<number>;\n  triggerPosition?: LayoutPosition;\n  setTriggerPosition: (position?: LayoutPosition) => void;\n  contentLayout?: LayoutRectangle;\n  setContentLayout: (position?: LayoutRectangle) => void;\n};\n\ntype PopoverProps = Partial<PopoverContextProps> & {\n  children: React.ReactNode;\n};\n\ntype PopoverPortalProps = Partial<React.ComponentProps<typeof Portal>>;\n\ntype PopoverOverlayProps = {\n  closeOnPress?: boolean;\n  className?: string;\n};\n\ntype PopoverContentProps = React.ComponentProps<typeof View> & {\n  avoidCollisions?: boolean;\n  side?: \"top\" | \"bottom\" | \"left\" | \"right\";\n  sideOffset?: number;\n  align?: \"start\" | \"center\" | \"end\";\n  alignOffset?: number;\n  width?: \"full\" | \"fit\" | \"auto\" | \"trigger\" | number | `${number}%`;\n  disablePositioningStyle?: boolean;\n};\n\ntype PopoverTriggerProps = React.ComponentPropsWithRef<typeof Pressable> & {\n  asChild?: boolean;\n};\n\ntype PopoverCloseProps = React.ComponentPropsWithRef<typeof Pressable> & {\n  asChild?: boolean;\n};\n\n// Context\nconst PopoverContext = createContext<PopoverContextProps | null>(null);\n\nconst usePopover = () => {\n  const context = useContext(PopoverContext);\n  if (!context) {\n    throw new Error(\"usePopover must be used within a Popover\");\n  }\n  return context;\n};\n\n// Components\nexport const Popover = ({\n  open: openProp,\n  onOpenChange,\n  children,\n}: PopoverProps) => {\n  const [internalOpen, setInternalOpen] = useState(openProp ?? false);\n  const [contentLayout, setContentLayout] = useState<LayoutRectangle>();\n  const [triggerPosition, setTriggerPosition] = useState<LayoutPosition>();\n\n  const isControlled = openProp !== undefined;\n  const open = isControlled ? openProp : internalOpen;\n\n  const visibilityProgress = useSharedValue(open ? 1 : 0);\n\n  const handleOpenChange = useCallback(\n    (nextOpen: boolean) => {\n      setInternalOpen(nextOpen);\n      onOpenChange?.(nextOpen);\n    },\n    [onOpenChange]\n  );\n\n  useEffect(() => {\n    visibilityProgress.value = withTiming(open ? 1 : 0, {\n      duration: ANIMATION_DURATION,\n    });\n  }, [open, visibilityProgress]);\n\n  const ctx = useMemo(\n    () => ({\n      open,\n      onOpenChange: handleOpenChange,\n      visibilityProgress,\n      contentLayout,\n      setContentLayout,\n      triggerPosition,\n      setTriggerPosition,\n    }),\n    [open, triggerPosition, contentLayout, visibilityProgress, handleOpenChange]\n  );\n\n  return (\n    <PopoverContext.Provider value={ctx}>{children}</PopoverContext.Provider>\n  );\n};\n\nexport const PopoverTrigger = ({\n  asChild,\n  onLayout: onLayoutProp,\n  ref: refProp,\n  ...props\n}: PopoverTriggerProps) => {\n  const { onOpenChange, setTriggerPosition } = usePopover();\n  const ref = useRef<React.ComponentRef<typeof Pressable>>(null);\n\n  const mergedRefs = mergeRefs(ref, refProp);\n\n  const handlePress = useCallback(\n    (e: GestureResponderEvent) => {\n      props.onPress?.(e);\n\n      ref.current?.measureInWindow((x, y, width, height) => {\n        setTriggerPosition({\n          pageX: x,\n          pageY: y,\n          width,\n          height,\n        });\n      });\n\n      onOpenChange(true);\n    },\n    [onOpenChange, props.onPress, setTriggerPosition]\n  );\n\n  const Comp = asChild ? Slot.Pressable : Pressable;\n\n  return <Comp {...props} onPress={handlePress} ref={mergedRefs} />;\n};\n\nexport const PopoverClose = ({ asChild, ...props }: PopoverCloseProps) => {\n  const { onOpenChange, setTriggerPosition } = usePopover();\n\n  const Comp = asChild ? Slot.Pressable : Pressable;\n\n  return (\n    <Comp\n      {...props}\n      onPress={() => {\n        onOpenChange(false);\n        setTriggerPosition(undefined);\n      }}\n    />\n  );\n};\n\nexport const PopoverPortal = ({\n  children,\n  name = \"popover-portal\",\n  ...portalProps\n}: PopoverPortalProps) => {\n  const ctx = usePopover();\n\n  if (!ctx.open) {\n    return null;\n  }\n\n  return (\n    <Portal name={name} {...portalProps}>\n      <PopoverContext.Provider value={ctx}>\n        <FullWindowOverlay>{children}</FullWindowOverlay>\n      </PopoverContext.Provider>\n    </Portal>\n  );\n};\n\nexport const PopoverOverlay = ({\n  closeOnPress = true,\n  className,\n}: PopoverOverlayProps) => {\n  const { onOpenChange, visibilityProgress } = usePopover();\n\n  const isDark = Uniwind.currentTheme === \"dark\";\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      visibilityProgress.value,\n      [0, 1],\n      [0, isDark ? 0.75 : 0.5],\n      Extrapolation.CLAMP\n    );\n\n    return {\n      opacity,\n    };\n  });\n\n  return (\n    <AnimatedPressable\n      className={cn(\"bg-black\", className)}\n      disabled={!closeOnPress}\n      onPress={() => onOpenChange(false)}\n      style={[StyleSheet.absoluteFill, animatedStyle]}\n    />\n  );\n};\n\nexport const PopoverContent = ({\n  children,\n  className,\n  onLayout: onLayoutProp,\n  style,\n  width = \"fit\",\n  avoidCollisions = true,\n  side = \"bottom\",\n  sideOffset = 8,\n  align = \"start\",\n  alignOffset = 0,\n  ...props\n}: PopoverContentProps) => {\n  const {\n    open,\n    visibilityProgress,\n    triggerPosition,\n    setContentLayout,\n    contentLayout,\n  } = usePopover();\n\n  const insets = useSafeAreaInsets();\n\n  const onLayout = useCallback(\n    (event: LayoutChangeEvent) => {\n      setContentLayout(event.nativeEvent.layout);\n      onLayoutProp?.(event);\n    },\n    [setContentLayout, onLayoutProp]\n  );\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      visibilityProgress.value,\n      [0, 1],\n      [0, 1],\n      Extrapolation.CLAMP\n    );\n\n    const scale = interpolate(\n      visibilityProgress.value,\n      [0, 1],\n      [0.95, 1],\n      Extrapolation.CLAMP\n    );\n\n    return {\n      opacity,\n      transform: [{ scale }],\n    };\n  });\n\n  const positionStyle = useRelativePosition({\n    align,\n    avoidCollisions,\n    triggerPosition: triggerPosition ?? null,\n    contentLayout: contentLayout ?? null,\n    alignOffset,\n    insets,\n    side,\n    sideOffset,\n  });\n\n  const widthStyle = useMemo(() => {\n    const _widthStyle: ViewStyle = {};\n    if (width === \"full\") {\n      _widthStyle.width = \"100%\";\n    }\n    if (typeof width === \"number\" || width === \"auto\" || width.endsWith(\"%\")) {\n      _widthStyle.width = width as DimensionValue;\n    }\n    if (width === \"trigger\") {\n      _widthStyle.width = triggerPosition?.width as DimensionValue;\n    }\n    return _widthStyle;\n  }, [width, triggerPosition]);\n\n  if (!open) {\n    return null;\n  }\n\n  if (!triggerPosition) {\n    return null;\n  }\n\n  return (\n    <Animated.View\n      {...props}\n      className={cn(\n        \"z-50 rounded-lg border border-border bg-background p-4 shadow-lg\",\n        className\n      )}\n      onLayout={onLayout}\n      style={[positionStyle, widthStyle, animatedStyle, style]}\n    >\n      {children}\n    </Animated.View>\n  );\n};\n",
      "type": "registry:ui"
    },
    {
      "path": "../../packages/tetra-ui/src/hooks/use-relative-position.ts",
      "content": "import { useMemo } from \"react\";\nimport {\n  Dimensions,\n  type LayoutRectangle,\n  type ScaledSize,\n} from \"react-native\";\nimport type { EdgeInsets } from \"react-native-safe-area-context\";\n\ntype LayoutPosition = {\n  pageX: number;\n  pageY: number;\n  width: number;\n  height: number;\n};\n\ntype UseRelativePositionArgs = {\n  align?: \"start\" | \"center\" | \"end\";\n  avoidCollisions?: boolean;\n  contentLayout: LayoutRectangle | null;\n  alignOffset?: number;\n  insets?: EdgeInsets;\n  side?: \"top\" | \"bottom\" | \"left\" | \"right\";\n  sideOffset?: number;\n  triggerPosition: LayoutPosition | null;\n};\n\ntype PositionStyle = {\n  position: \"absolute\";\n  top?: number;\n  left?: number;\n  maxWidth?: number;\n  maxHeight?: number;\n  opacity?: number;\n};\n\ntype SidePositionParams = {\n  side: \"top\" | \"bottom\" | \"left\" | \"right\";\n  triggerPosition: LayoutPosition;\n  contentLayout: LayoutRectangle;\n  sideOffset: number;\n  insets?: EdgeInsets;\n  avoidCollisions: boolean;\n  dimensions: ScaledSize;\n};\n\nfunction getVerticalSidePosition({\n  side,\n  triggerPosition,\n  contentLayout,\n  sideOffset,\n  insetTop,\n  insetBottom,\n  avoidCollisions,\n  dimensions,\n}: {\n  side: \"top\" | \"bottom\";\n  triggerPosition: LayoutPosition;\n  contentLayout: LayoutRectangle;\n  sideOffset: number;\n  insetTop: number;\n  insetBottom: number;\n  avoidCollisions: boolean;\n  dimensions: ScaledSize;\n}): { top?: number } {\n  const positionTop = triggerPosition.pageY - sideOffset - contentLayout.height;\n  const positionBottom =\n    triggerPosition.pageY + triggerPosition.height + sideOffset;\n\n  if (!avoidCollisions) {\n    return {\n      top: side === \"top\" ? positionTop : positionBottom,\n    };\n  }\n\n  if (side === \"top\") {\n    const clampedTop = Math.max(insetTop, positionTop);\n    return {\n      top: Math.min(\n        clampedTop,\n        dimensions.height - insetBottom - contentLayout.height\n      ),\n    };\n  }\n\n  const maxBottom = dimensions.height - insetBottom - contentLayout.height;\n\n  if (positionBottom > maxBottom) {\n    const topPosition =\n      triggerPosition.pageY - sideOffset - contentLayout.height;\n\n    if (topPosition >= insetTop) {\n      return { top: topPosition };\n    }\n\n    return {\n      top: Math.max(insetTop, Math.min(positionBottom, maxBottom)),\n    };\n  }\n\n  return {\n    top: Math.max(insetTop, Math.min(positionBottom, maxBottom)),\n  };\n}\n\nfunction getHorizontalSidePosition({\n  side,\n  triggerPosition,\n  contentLayout,\n  sideOffset,\n  insetLeft,\n  insetRight,\n  avoidCollisions,\n  dimensions,\n}: {\n  side: \"left\" | \"right\";\n  triggerPosition: LayoutPosition;\n  contentLayout: LayoutRectangle;\n  sideOffset: number;\n  insetLeft: number;\n  insetRight: number;\n  avoidCollisions: boolean;\n  dimensions: ScaledSize;\n}): { left?: number } {\n  const maxContentWidth = dimensions.width - insetLeft - insetRight;\n  const contentWidth = Math.min(contentLayout.width, maxContentWidth);\n\n  const positionLeft = triggerPosition.pageX - sideOffset - contentWidth;\n  const positionRight =\n    triggerPosition.pageX + triggerPosition.width + sideOffset;\n\n  if (!avoidCollisions) {\n    return {\n      left: side === \"left\" ? positionLeft : positionRight,\n    };\n  }\n\n  const minLeft = insetLeft;\n  const maxLeft = dimensions.width - insetRight - contentWidth;\n\n  if (side === \"left\") {\n    return {\n      left: Math.max(minLeft, Math.min(maxLeft, positionLeft)),\n    };\n  }\n\n  return {\n    left: Math.max(minLeft, Math.min(maxLeft, positionRight)),\n  };\n}\n\nfunction getSidePosition({\n  side = \"bottom\",\n  triggerPosition,\n  contentLayout,\n  sideOffset = 0,\n  insets,\n  avoidCollisions = true,\n  dimensions,\n}: SidePositionParams): { top?: number; left?: number } {\n  const insetTop = insets?.top ?? 0;\n  const insetBottom = insets?.bottom ?? 0;\n  const insetLeft = insets?.left ?? 0;\n  const insetRight = insets?.right ?? 0;\n\n  // Handle vertical sides (top/bottom)\n  if (side === \"top\" || side === \"bottom\") {\n    return getVerticalSidePosition({\n      side,\n      triggerPosition,\n      contentLayout,\n      sideOffset,\n      insetTop,\n      insetBottom,\n      avoidCollisions,\n      dimensions,\n    });\n  }\n\n  // Handle horizontal sides (left/right)\n  return getHorizontalSidePosition({\n    side,\n    triggerPosition,\n    contentLayout,\n    sideOffset,\n    insetLeft,\n    insetRight,\n    avoidCollisions,\n    dimensions,\n  });\n}\n\ntype HorizontalAlignParams = {\n  align: \"start\" | \"center\" | \"end\";\n  triggerPageX: number;\n  triggerWidth: number;\n  contentWidth: number;\n  alignOffset: number;\n  insetLeft: number;\n  insetRight: number;\n  dimensions: ScaledSize;\n};\n\nfunction getHorizontalAlignPosition({\n  align,\n  triggerPageX,\n  triggerWidth,\n  contentWidth,\n  alignOffset,\n  insetLeft,\n  insetRight,\n  dimensions,\n}: HorizontalAlignParams): number {\n  let left = 0;\n  if (align === \"start\") {\n    left = triggerPageX;\n  }\n  if (align === \"center\") {\n    left = triggerPageX + triggerWidth / 2 - contentWidth / 2;\n  }\n  if (align === \"end\") {\n    left = triggerPageX + triggerWidth - contentWidth;\n  }\n  return Math.max(\n    insetLeft,\n    Math.min(left + alignOffset, dimensions.width - contentWidth - insetRight)\n  );\n}\n\ntype VerticalAlignParams = {\n  align: \"start\" | \"center\" | \"end\";\n  triggerPageY: number;\n  triggerHeight: number;\n  contentHeight: number;\n  alignOffset: number;\n  insetTop: number;\n  insetBottom: number;\n  dimensions: ScaledSize;\n};\n\nfunction getVerticalAlignPosition({\n  align,\n  triggerPageY,\n  triggerHeight,\n  contentHeight,\n  alignOffset,\n  insetTop,\n  insetBottom,\n  dimensions,\n}: VerticalAlignParams): number {\n  let top = 0;\n  if (align === \"start\") {\n    top = triggerPageY;\n  }\n  if (align === \"center\") {\n    top = triggerPageY + triggerHeight / 2 - contentHeight / 2;\n  }\n  if (align === \"end\") {\n    top = triggerPageY + triggerHeight - contentHeight;\n  }\n  return Math.max(\n    insetTop,\n    Math.min(top + alignOffset, dimensions.height - contentHeight - insetBottom)\n  );\n}\n\ntype AlignPositionParams = {\n  align: \"start\" | \"center\" | \"end\";\n  avoidCollisions: boolean;\n  triggerPosition: LayoutPosition;\n  contentLayout: LayoutRectangle;\n  alignOffset: number;\n  insets?: EdgeInsets;\n  side: \"top\" | \"bottom\" | \"left\" | \"right\";\n  dimensions: ScaledSize;\n};\n\nfunction adjustHorizontalCollision({\n  left,\n  contentWidth,\n  insetLeft,\n  insetRight,\n  dimensions,\n}: {\n  left: number;\n  contentWidth: number;\n  insetLeft: number;\n  insetRight: number;\n  dimensions: ScaledSize;\n}): number {\n  const spaceLeft = left - insetLeft;\n  const spaceRight = dimensions.width - insetRight - (left + contentWidth);\n\n  if (spaceLeft > spaceRight && spaceLeft >= contentWidth) {\n    return insetLeft;\n  }\n  if (spaceRight >= contentWidth) {\n    return dimensions.width - insetRight - contentWidth;\n  }\n  return Math.max(\n    insetLeft,\n    (dimensions.width - contentWidth - insetRight) / 2\n  );\n}\n\nfunction getHorizontalAlignWithCollision({\n  align,\n  triggerPosition,\n  contentWidth,\n  alignOffset,\n  insetLeft,\n  insetRight,\n  avoidCollisions,\n  dimensions,\n}: {\n  align: \"start\" | \"center\" | \"end\";\n  triggerPosition: LayoutPosition;\n  contentWidth: number;\n  alignOffset: number;\n  insetLeft: number;\n  insetRight: number;\n  avoidCollisions: boolean;\n  dimensions: ScaledSize;\n}): number {\n  let left = getHorizontalAlignPosition({\n    align,\n    triggerPageX: triggerPosition.pageX,\n    triggerWidth: triggerPosition.width,\n    contentWidth,\n    alignOffset,\n    insetLeft,\n    insetRight,\n    dimensions,\n  });\n\n  if (avoidCollisions) {\n    const doesCollide =\n      left < insetLeft || left + contentWidth > dimensions.width - insetRight;\n    if (doesCollide) {\n      left = adjustHorizontalCollision({\n        left,\n        contentWidth,\n        insetLeft,\n        insetRight,\n        dimensions,\n      });\n    }\n  }\n\n  return left;\n}\n\nfunction adjustVerticalCollision({\n  idealTop,\n  contentHeight,\n  insetTop,\n  insetBottom,\n  dimensions,\n}: {\n  idealTop: number;\n  contentHeight: number;\n  insetTop: number;\n  insetBottom: number;\n  dimensions: ScaledSize;\n}): number {\n  const spaceTop = idealTop - insetTop;\n  const spaceBottom =\n    dimensions.height - insetBottom - (idealTop + contentHeight);\n\n  if (spaceTop > spaceBottom && spaceTop >= contentHeight) {\n    return insetTop;\n  }\n  if (spaceBottom >= contentHeight) {\n    return dimensions.height - insetBottom - contentHeight;\n  }\n  return Math.max(\n    insetTop,\n    (dimensions.height - contentHeight - insetBottom) / 2\n  );\n}\n\nfunction getVerticalAlignWithCollision({\n  verticalAlign,\n  triggerPosition,\n  contentHeight,\n  alignOffset,\n  insetTop,\n  insetBottom,\n  avoidCollisions,\n  dimensions,\n}: {\n  verticalAlign: \"start\" | \"center\" | \"end\";\n  triggerPosition: LayoutPosition;\n  contentHeight: number;\n  alignOffset: number;\n  insetTop: number;\n  insetBottom: number;\n  avoidCollisions: boolean;\n  dimensions: ScaledSize;\n}): number {\n  let top = getVerticalAlignPosition({\n    align: verticalAlign,\n    triggerPageY: triggerPosition.pageY,\n    triggerHeight: triggerPosition.height,\n    contentHeight,\n    alignOffset,\n    insetTop,\n    insetBottom,\n    dimensions,\n  });\n\n  if (avoidCollisions) {\n    const doesCollide =\n      top < insetTop || top + contentHeight > dimensions.height - insetBottom;\n    if (doesCollide) {\n      const triggerCenter = triggerPosition.pageY + triggerPosition.height / 2;\n      const idealTop = triggerCenter - contentHeight / 2;\n\n      if (\n        idealTop >= insetTop &&\n        idealTop + contentHeight <= dimensions.height - insetBottom\n      ) {\n        top = idealTop;\n      } else {\n        top = adjustVerticalCollision({\n          idealTop,\n          contentHeight,\n          insetTop,\n          insetBottom,\n          dimensions,\n        });\n      }\n    }\n  }\n\n  return top;\n}\n\nfunction getAlignPosition({\n  align = \"start\",\n  avoidCollisions = true,\n  triggerPosition,\n  contentLayout,\n  alignOffset = 0,\n  insets,\n  side = \"bottom\",\n  dimensions,\n}: AlignPositionParams): {\n  top?: number;\n  left?: number;\n  maxWidth?: number;\n  maxHeight?: number;\n} {\n  const insetTop = insets?.top ?? 0;\n  const insetBottom = insets?.bottom ?? 0;\n  const insetLeft = insets?.left ?? 0;\n  const insetRight = insets?.right ?? 0;\n\n  // For top/bottom sides, align horizontally\n  if (side === \"top\" || side === \"bottom\") {\n    const maxContentWidth = dimensions.width - insetLeft - insetRight;\n    const contentWidth = Math.min(contentLayout.width, maxContentWidth);\n\n    const left = getHorizontalAlignWithCollision({\n      align,\n      triggerPosition,\n      contentWidth,\n      alignOffset,\n      insetLeft,\n      insetRight,\n      avoidCollisions,\n      dimensions,\n    });\n\n    return { left, maxWidth: maxContentWidth };\n  }\n\n  // For left/right sides, align vertically and constrain width\n  // Default to \"center\" alignment for left/right sides for better UX\n  const verticalAlign =\n    (side === \"left\" || side === \"right\") && align === \"start\"\n      ? \"center\"\n      : align;\n\n  const maxContentHeight = dimensions.height - insetTop - insetBottom;\n  const maxContentWidth = dimensions.width - insetLeft - insetRight;\n  const contentHeight = Math.min(contentLayout.height, maxContentHeight);\n\n  const top = getVerticalAlignWithCollision({\n    verticalAlign,\n    triggerPosition,\n    contentHeight,\n    alignOffset,\n    insetTop,\n    insetBottom,\n    avoidCollisions,\n    dimensions,\n  });\n\n  return { top, maxHeight: maxContentHeight, maxWidth: maxContentWidth };\n}\n\nfunction getEstimatedPosition({\n  align,\n  triggerPosition,\n  side,\n  sideOffset,\n  alignOffset,\n}: {\n  align: \"start\" | \"center\" | \"end\";\n  triggerPosition: LayoutPosition;\n  side: \"top\" | \"bottom\" | \"left\" | \"right\";\n  sideOffset: number;\n  alignOffset: number;\n}): { top: number; left: number } {\n  // Position near trigger but invisible until layout is measured\n  // Use a rough estimate for positioning\n  const estimatedHeight = 100; // Rough estimate, will be corrected after layout\n  const estimatedWidth = 200;\n\n  let top = 0;\n  let left = 0;\n\n  if (side === \"top\" || side === \"bottom\") {\n    top =\n      side === \"top\"\n        ? triggerPosition.pageY - sideOffset - estimatedHeight\n        : triggerPosition.pageY + triggerPosition.height + sideOffset;\n\n    // Calculate horizontal alignment\n    if (align === \"start\") {\n      left = triggerPosition.pageX;\n    } else if (align === \"center\") {\n      left =\n        triggerPosition.pageX + triggerPosition.width / 2 - estimatedWidth / 2;\n    } else {\n      left = triggerPosition.pageX + triggerPosition.width - estimatedWidth;\n    }\n    left += alignOffset;\n  } else {\n    left =\n      side === \"left\"\n        ? triggerPosition.pageX - sideOffset - estimatedWidth\n        : triggerPosition.pageX + triggerPosition.width + sideOffset;\n\n    // Calculate vertical alignment\n    if (align === \"start\") {\n      top = triggerPosition.pageY;\n    } else if (align === \"center\") {\n      top =\n        triggerPosition.pageY +\n        triggerPosition.height / 2 -\n        estimatedHeight / 2;\n    } else {\n      top = triggerPosition.pageY + triggerPosition.height - estimatedHeight;\n    }\n    top += alignOffset;\n  }\n\n  return { top, left };\n}\n\nexport function useRelativePosition({\n  align = \"start\",\n  avoidCollisions = true,\n  triggerPosition,\n  contentLayout,\n  alignOffset = 0,\n  insets,\n  side = \"bottom\",\n  sideOffset = 0,\n}: UseRelativePositionArgs): PositionStyle {\n  return useMemo(() => {\n    const dimensions = Dimensions.get(\"screen\");\n\n    if (!triggerPosition) {\n      return {\n        position: \"absolute\",\n        opacity: 0,\n        top: -9999,\n        left: -9999,\n      };\n    }\n\n    if (!contentLayout) {\n      return {\n        position: \"absolute\",\n        ...getEstimatedPosition({\n          align,\n          triggerPosition,\n          side,\n          sideOffset,\n          alignOffset,\n        }),\n      };\n    }\n\n    const sidePosition = getSidePosition({\n      side,\n      triggerPosition,\n      contentLayout,\n      sideOffset,\n      insets,\n      avoidCollisions,\n      dimensions,\n    });\n\n    const alignPosition = getAlignPosition({\n      align,\n      avoidCollisions,\n      triggerPosition,\n      contentLayout,\n      alignOffset,\n      insets,\n      side,\n      dimensions,\n    });\n\n    return {\n      position: \"absolute\" as const,\n      ...sidePosition,\n      ...alignPosition,\n    };\n  }, [\n    align,\n    avoidCollisions,\n    side,\n    alignOffset,\n    insets,\n    triggerPosition,\n    contentLayout,\n    sideOffset,\n  ]);\n}\n",
      "type": "registry:hook"
    }
  ]
}